Enum class Tokens.
	Позволяет удобным образом интерпретировать командные символы Brainfuck.

Object BrainfuckCompiler.
	memorySize - размер памяти, доступной компилируемой программе. Почему это не вынесено в глобальную константу, если у интерпретатора она такая же?
	
	Стек labels нужен для отслеживания текущего loop-а.

	isFirstLoop - назначение понятно из названия, нужен потому что, видимо, при входе в первый цикл выделяется какая-то память и происходит что-то еще. 
	Однако, по строчке "visitFrame(F_APPEND, 2, arrayOf("[C", INTEGER), 0, null)" (в методе MethodVisitor.visitBrainfuckWhileInsn()) я так и не понял, что именно.
	Захардкоженные константы без описания - наше все. Также непонятно, почему нельзя проверять, первый это цикл или нет, по размеру стека labels.

	generateClassByteArray(commands: String, className: String): ByteArray  
	Основной метод, принимающий на вход программу - последовательность команд на языке Brainfuck - в виде строки, и имя класса, который необходимо сгенерировать, 
	и выдающий байт-код сгенерированного класса в формате ByteArray.
	Очень длинное название метода.
	Создав переменную cw (а вот здесь по названию догадаться о содержании сложновато) - экземпляр класса ClassWriter, который, собственно, и предназначен для 
	создания байткодовых классов, мы затем добавляем заголовок генерируемого класса.
	Создание конструктора закомментировано (видимо, потому что в генерируемом классе не будет свойств и полей, которые надо было бы инициализировать), возможно, 
	его стоит удалить совсем?
	Затем создается main-метод класса, который и будет, по сути, скомпилированной программой пользователя.
	Создание main-метода - это довольно много кода. Возможно, стоило бы вынести в отдельную функцию.
	Создаем массив - память, с которой будет работать программа пользователя, выставляем указатель памяти на нулевую ячейку.
	Устанавливаем переменную isFirstLoop в true, затем в цикле для каждого символа - команды Brainfuck - запускаем метод, генерирующий соответствующую 
	последовательность команд в байт-коде.
	После цикла завершаем генерацию main-метода (в том числе, устанавливаем максимальный размер стека и количество локальных переменных непонятно откуда взятыми 
	захардкоженными четверкой и тройкой).
	Завершаем генерацию самого класса и возвращаем его представление в виде ByteArray.

	Шесть методов, генерирующих байт-код для соответствующих команд Brainfuck. Очень удобно, что сверху в комментарии подписано, где какая.

Class CompilerTest.
	Метод TestCompiler (а еще б он был написан первым, а не в конце файла. Все же если все остальные методы ссылаются на этот, стоит описать его в начале файла) 
	принимает на вход три строки - программу на brainfuck, ввод и требуемый вывод. 
	Метод компилирует переданную ему программу, проверяя корректность компиляции (наличие хотя бы одного метода. Что интересно, если в сгенерированном классе 
	каким-то образом окажется хотя бы один метод, но не будет main-метода, тест ошибки не заметит от слова совсем), перенаправляет потоки ввода и вывода, после 
	чего запускает метод main сгенерированного класса и проверяет равенство реального и требуемого вывода.

	Метод ByteArrayClassLoader превращает ByteArray в java class.

	Остальные методы - тестовые, они проверяют корректность работы компилятора на различных входных данных, используя метод TestCompiler.

Object BrainfuckInterpreter.
	Все та же константа memorySize, что и в компиляторе.

	Функция interpret, принимающая на вход программу на Brainfuck в виде строки, а также поток ввода и поток вывода.
	Здесь автор почему-то вспомнил, что хардкодить константы нехорошо, и сделал константу для нулевого байта. Стоило ли так делать - для меня вопрос, все же 
	инициализацию нулями вряд ли когда-либо придется менять на инициализацию чем-то другим.
	Выделяется память, заводятся "указатели" (почему они названы Ptr, если это не указатели, а индексы?) на текущую команду (индекс символа в строке-программе, 
	исходно - 0) и текущую ячейку в выделенном массиве памяти (тоже исходно 0), честным образом выполняются команды.

Сlass InterpreterTest.
	Class StringReader позволяет посимвольно считывать из переданной строки. 
	Почему его нельзя было сделать object или companion object? 

	class StringWriter позволяет складывать вывод в свою внутреннюю переменную и получать этот вывод методом toString. Отметим, что буфер при этом не сбрасывается,
	то есть, если нам понадобится считывать вывод больше одного раза, к нужной части вывода слева будет прилеплен весь старый.
	метод testInterpreter принимает на вход три строки - программу на brainfuck, ввод и требуемый вывод. 
	После чего заводит StringWriter для складирования вывода, интерпретирует переданную ему программу со StringReader-ом, созданным из переданного ввода и 
	заведенным ранее StringWriter-ом для вывода, после чего проверяет равенство ожидаемого и реального вывода.

	Остальные методы - тестовые, они проверяют корректность работы компилятора на различных входных данных, используя метод TestCompiler.

Комментарии ревьюеров.
	Был только один, про необходимость валидации ввода (проверки правильности скобочной последовательности). Согласен, это стоило бы сделать.

Улучшение кода с помощью новых возможностей Kotlin.
	Я таких возможностей в коде не увидел.